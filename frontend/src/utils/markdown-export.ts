/**
 * Utility functions for exporting PRD data to Markdown format
 * Compatible with cv-md viewer
 */

export interface PRDChunk {
  id: string
  type: string
  text: string
  priority: string
  section_title?: string
  tags?: string[]
  optimized?: boolean
  optimization_notes?: string
}

export interface PRDData {
  id: string
  name: string
  description?: string
  source_file?: string
  created_at?: string
  chunks: PRDChunk[]
}

/**
 * Group chunks by section/type
 */
function groupChunks(chunks: PRDChunk[]): Record<string, PRDChunk[]> {
  return chunks.reduce((acc: Record<string, PRDChunk[]>, chunk: PRDChunk) => {
    const section = chunk.section_title || chunk.type || 'General'
    if (!acc[section]) {
      acc[section] = []
    }
    acc[section].push(chunk)
    return acc
  }, {})
}

/**
 * Get emoji/icon for chunk type
 */
function getChunkTypeIcon(type: string): string {
  const icons: Record<string, string> = {
    requirement: 'üìã',
    feature: '‚ú®',
    constraint: 'üîí',
    stakeholder: 'üë•',
    metric: 'üìä',
    dependency: 'üîó',
    risk: '‚ö†Ô∏è',
    objective: 'üéØ',
    overview: 'üìÑ',
  }
  return icons[(type || 'unknown').toLowerCase()] || '‚Ä¢'
}

/**
 * Get priority badge
 */
function getPriorityBadge(priority: string): string {
  const badges: Record<string, string> = {
    critical: 'üî¥ Critical',
    high: 'üü† High',
    medium: 'üü° Medium',
    low: 'üü¢ Low',
  }
  return badges[(priority || 'medium').toLowerCase()] || priority || 'Medium'
}

/**
 * Convert PRD data to Markdown format
 */
export function prdToMarkdown(prd: PRDData): string {
  const lines: string[] = []

  // Header
  lines.push(`# ${prd.name}`)
  lines.push('')

  if (prd.description) {
    lines.push(`> ${prd.description}`)
    lines.push('')
  }

  // Metadata
  lines.push('## Document Info')
  lines.push('')
  lines.push(`- **PRD ID:** \`${prd.id}\``)
  if (prd.source_file) {
    lines.push(`- **Source File:** ${prd.source_file}`)
  }
  if (prd.created_at) {
    const date = new Date(prd.created_at).toLocaleString()
    lines.push(`- **Created:** ${date}`)
  }
  lines.push(`- **Total Items:** ${prd.chunks?.length || 0}`)
  lines.push('')

  // Chunks by section
  const groupedChunks = groupChunks(prd.chunks || [])

  for (const [section, chunks] of Object.entries(groupedChunks)) {
    lines.push(`## ${section}`)
    lines.push('')

    for (const chunk of chunks) {
      const icon = getChunkTypeIcon(chunk.type)
      const priority = getPriorityBadge(chunk.priority)

      lines.push(`### ${icon} ${chunk.type}`)
      lines.push('')
      lines.push(`**Priority:** ${priority}`)
      if (chunk.tags && chunk.tags.length > 0) {
        lines.push(`**Tags:** ${chunk.tags.join(', ')}`)
      }
      lines.push('')
      lines.push(chunk.text)
      lines.push('')

      if (chunk.optimized) {
        lines.push('> ‚úì *Optimized for AI Paired Programming*')
        if (chunk.optimization_notes) {
          lines.push(`> ${chunk.optimization_notes}`)
        }
        lines.push('')
      }

      lines.push('---')
      lines.push('')
    }
  }

  // Footer
  lines.push('---')
  lines.push('')
  lines.push('*Generated by cvPRD - AI-Powered Product Requirements Documentation*')
  lines.push('')

  return lines.join('\n')
}

/**
 * Download PRD as Markdown file
 */
export function downloadMarkdown(prd: PRDData): void {
  const markdown = prdToMarkdown(prd)
  const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' })
  const url = URL.createObjectURL(blob)

  const a = document.createElement('a')
  a.href = url
  a.download = `${prd.name.replace(/[^a-zA-Z0-9]/g, '_')}.md`
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)

  URL.revokeObjectURL(url)
}

/**
 * Copy Markdown to clipboard
 */
export async function copyMarkdownToClipboard(prd: PRDData): Promise<boolean> {
  try {
    const markdown = prdToMarkdown(prd)
    await navigator.clipboard.writeText(markdown)
    return true
  } catch (err) {
    console.error('Failed to copy to clipboard:', err)
    return false
  }
}
